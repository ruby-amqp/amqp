# @title Ruby AMQP gem: Working with exchanges

h1. Working with exchanges


h2. About this guide

This guide covers exchanges in AMQP 0.9.1, message publishing, common usage scenarios and how to accomplish typical operations using
Ruby amqp gem.


h2. Covered versions

This guide covers "Ruby amqp gem":http://github.com/ruby-amqp/amqp v0.8.0 and later.


h2. Exchanges in AMQP 0.9.1, briefly

h3. What are AMQP exchanges?

An exchange accepts messages from a producer application and routes these to message queues. They can be thought of as "mailboxes" of AMQP
world. Unlike some other messaging middleware products and protocols, in AMQP messages are *not* published directly to queues: they
are published to exchanges that route them to queue(s) using pre-arranged criteria (called bindings).

There are multiple exchange types in AMQP 0.9.1, each with its own routing semantics. Custom exchange types can be created to cover
sophisticated routing scenarios (for example, routing based on geolocation data), edge cases or just for convenience.


h3. Concept of bindings

Binding is an association between a queue and an exchange. Queues must be bound to at least one exchange in order to receive messages from publishers.
Learn more about bindings in {file:docs/Bindings.textile Bindings guide}.


h3. Attributes

Exchanges have several attributes associated with them:

 * Name
 * Type (direct, fanout, topic, headers or some custom type)
 * Durability
 * Whether exchange is auto-deleted when no longer used
 * Other metadata (aka X-arguments)


h2. Exchange types

There are 4 built-in exchange types in AMQP 0.9.1:

 * Direct
 * Fanout
 * Topic
 * Headers

As stated previously, each exchange type has own routing semantics and new exchange types can be added by extending brokers with plugins.
Custom exchange types begin with x-, much like custom HTTP headers, for example, "x-recent-history exchange":https://github.com/videlalvaro/rabbitmq-recent-history-exchange
or "x-random exchange":https://github.com/jbrisbin/random-exchange.




h2. Message attributes

Before we start looking at various exchange types and their routing semantics, we need to introduce idea of message attributes.
Every AMQP message has a number of *attributes*. Some attributes are important and used very often, other are used rarely. AMQP message attributes are metadata:
they are similar in purpose to HTTP request and response headers.

Every AMQP 0.9.1 message has an attribute called the *routing key*. The routing key is an "address" that the exchange may use to decide how to route
the message (similar to, but more generic than, URL in HTTP). Most exchange types use routing key to implement routing logic, but some ignore
it and use other criteria (for example, message content).




h2. Fanout exchanges

h3. How fanout exchanges route messages

Fanout exchanges route messages to all queues bound to it, the routing key is ignored. If N queues are bound to a fanout exchange,
when a new message is published to that exchange, a *copy of the message* is delivered to all N queues, so fanout exchanges
are ideal for "broadcast routing":http://en.wikipedia.org/wiki/Broadcasting_%28computing%29 of messages.

Graphically this can be represented as

!http://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/500px-Broadcast.svg.png!


h3. Declaring a fanout exchange

There are two ways to declare a fanout exchange: using by instantiating {AMQP::Exchange} and specifying type as `:fanout`, or
with {AMQP::Channel#fanout}. Two examples to demonstrate:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :fanout, "nodes.metadata")
</code>
</pre>

<pre>
<code>
exchange = channel.fanout("nodes.metadata")
</code>
</pre>

Both methods asynchronously declare a queue. Because declaration takes a network roundtrip, publishing operations on {AMQP::Exchange} instances are
delayed until broker reply (exchange.declare-ok) is received.


Both methods let you pass a block to run a piece of code when broker responds with exchange.declare-ok (meaning exchange is successfully declared).

<pre>
<code>
channel.fanout("nodes.metadata") do |exchange|
  # exchange is declared and ready to be used.
end
</code>
</pre>

h3. Routing example

To demonstrate this routing behavior, we can declare 10 server-named exclusive queues and bind them all to one fanout exchange,
then publish a message there:

<pre>
<code>
exchange = channel.topic("amqpgem.examples.routing.fanout_routing", :auto_delete => true)

10.times do
  q = channel.queue("", :exclusive => true, :auto_delete => true).bind(exchange)
  q.subscribe do |payload|
    puts "Queue #{q.name} received #{payload}"
  end
end
</code>
</pre>

<pre>
<code>
# Publish some test data in a bit, after all queues are declared & bound
EventMachine.add_timer(1.2) { exchange.publish "Hello, fanout exchanges world!" }
</code>
</pre>

When run, this example produces the following output:

<pre>
Queue amq.gen-0p/BjxGNCue42RcJhpUrdg== received Hello, fanout exchanges world!
Queue amq.gen-3GXULvZuYh1KsOD83yvlNg== received Hello, fanout exchanges world!
Queue amq.gen-4EcyydTfoZzXjNSSLsh09Q== received Hello, fanout exchanges world!
Queue amq.gen-B1isyTpR5svB6ClQ2TQEBQ== received Hello, fanout exchanges world!
Queue amq.gen-FwLLioB7Mk4LGA4yJ1Mo7A== received Hello, fanout exchanges world!
Queue amq.gen-OtBQokiA/DmNkB5bPzaRig== received Hello, fanout exchanges world!
Queue amq.gen-RYHQUrj3yihb0DRF7KVpRg== received Hello, fanout exchanges world!
Queue amq.gen-SZJ40mGwbhdcbOGeHMhUkg== received Hello, fanout exchanges world!
Queue amq.gen-sDeVZg9Vx1knq+n9EMi8tA== received Hello, fanout exchanges world!
Queue amq.gen-uWOuVaosW4bWAHqKG6pZVw== received Hello, fanout exchanges world!
</pre>

All the queues bound to the exchange receives a *copy* of the message.


Full example:
<script src="https://gist.github.com/1020181.js"> </script>


h3. Use cases

Because fanout exchanges deliver a copy of a message to every queue bound to it, use cases for it are quite similar:

 * MMO games can use it for leaderboard updates or other global events.
 * Sport news sites can use fanout exchanges for distributing score updates to mobile clients in near real-time.
 * Distributed systems can broadcast various state and configuration updates.
 * Group chats can distribute messages between participants using a fanout exchange (although AMQP doesn't have built-in concept of presence, so "XMPP":http://xmpp.org may be a better choice)


h3. Pre-declared fanout exchanges

AMQP 0.9.1 brokers must implement fanout exchange type and pre-declare one instance with the name of "amq.fanout".
Applications can rely on that exchange to always be available to them. Each vhost has a separate instance of that exchange,
it is *not shared across vhosts* for obvious reasons.

TBD




h2. Direct exchanges

h3. How direct exchanges route messages

Direct exchange delivers messages to queues based on *message routing key*, an attribute every AMQP 0.9.1 message has.

Here is how it works:

 * A queue binds to the exchange with a routing key, K.
 * When a new message with routing key R arrives to direct exchange, the exchange routes it to the queue if K = R.

Direct exchange is ideal for "unicast routing":http://en.wikipedia.org/wiki/Unicast of messages (although it can be used for "multicast routing":http://en.wikipedia.org/wiki/Multicast, too).

!http://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/500px-Unicast.svg.png!


h3. Declaring a direct exchange

There are two ways to declare a direct exchange: using by instantiating {AMQP::Exchange} and specifying type as `:direct`, or
with {AMQP::Channel#direct}. Two examples to demonstrate:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :direct, "nodes.metadata")
</code>
</pre>

<pre>
<code>
exchange = channel.direct("nodes.metadata")
</code>
</pre>

Both methods asynchronously declare a queue. Because declaration takes a network roundtrip, publishing operations on {AMQP::Exchange} instances are
delayed until broker reply (exchange.declare-ok) is received.


Both methods let you pass a block to run a piece of code when broker responds with exchange.declare-ok (meaning exchange is successfully declared).

<pre>
<code>
channel.direct("pages.content.extraction") do |exchange|
  # exchange is declared and ready to be used.
end
</code>
</pre>


h3. Routing example

TBD


h3. Use cases

TBD


h3. Pre-declared direct exchanges

AMQP 0.9.1 brokers must implement direct exchange type and pre-declare two instances

 * *amq.direct*.
 * *""* (unnamed, referred to as an empty string by many clients including amqp Ruby gem) exchange known as *default exchange*.

Applications can rely on those exchanges to always be available to them. Each vhost has separate instances of those exchanges,
they are *not shared across vhosts* for obvious reasons.


h3. Default exchange

Default exchange is a direct exchange with no name (amqp gem refers to it using an empty string) pre-declared by the broker. It has one key special
property that makes it very useful for simple applications: *every queue is automatically bound to it with a routing key the same as queue name".

For example, when you declare a queue with the name of "search.indexing.online", AMQP broker will bind it to the default exchange using
"search.indexing.online" as routing key. So a message publishes to the default exchange with routing key = "search.indexing.online"
will be routed to the queue "search.indexing.online". In other words, default exchange makes it possible to "deliver messages directly to queues",
even though that is not technically correct.


amqp gem offers two ways of obtaining of the default exchange: {AMQP::Channel#default_exchange} and {AMQP::Channel#direct} (use  empty string as exchange name).
{AMQP::Exchange#initialize} can be used as well but requires more effort and for this particular case offers no benefits over instance methods on {AMQP::Channel}.

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :direct, "")
</code>
</pre>

<pre>
<code>
exchange = channel.default_exchange
</code>
</pre>

<pre>
<code>
exchange = channel.direct("")
</code>
</pre>



The default exchange is what the "Hello, World" example uses:

{include:file:examples/hello_world.rb}



h2. Topic exchanges

h3. How topic exchanges route messages

Topic exchanges route messages to one or many queues based on matching between message routing key and pattern that was used for binding
queue to the exchange. This exchange type is often used to implement various "publish/subscribe pattern":http://en.wikipedia.org/wiki/Publish/subscribe variations.


Topic exchanges are commonly used for "multicast routing":http://en.wikipedia.org/wiki/Multicast of messages.

!http://upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/500px-Multicast.svg.png!

Topic exchanges can be used for "broadcast routing":http://en.wikipedia.org/wiki/Broadcasting_%28computing%29 but usually fanout exchanges are more efficient at that.


h3. Routing example

Two classic examples of topic-based routing are stocks price updates and location-specific data (for instance, weather broadcasts).
Consumers indicate what topics they are interested in (think of it as of subscribing to a feed for individual tag
of your favourite blog as opposed to full feed). They do it by specifying a _routing pattern_ to {AMQP::Queue#bind} method, for example:

<pre>
<code>
channel.queue("americas.south").bind(exchange, :routing_key => "americas.south.#").subscribe do |headers, payload|
  puts "An update for South America: #{payload}, routing key is #{headers.routing_key}"
end
</code>
</pre>

In the example above we bind a queue with the name of "americas.south" to the topic exchange declared earlier using {AMQP::Queue#bind} method.
This means that only messages with routing key matching americas.south.# will be routed to that queue. Routing pattern consists of several words
separated by dots, similarly to URI path segments joined by slash. A few of examples:

 * asia.southeast.thailand.bangkok
 * sports.basketball
 * usa.nasdaq.aapl
 * tasks.search.indexing.accounts

The following routing keys do match "americas.south.#" pattern:

 * americas.south
 * americas.south.*brazil*
 * americas.south.*brazil.saopaolo*
 * americas.south.*chile.santiago*

In other words, # part of the pattern matches 0 or more words. For "americas.south.*", some of matching routing keys are

 * americas.south.*brazil*
 * americas.south.*chile*
 * americas.south.*peru*

but not

 * americas.south
 * americas.south.chile.santiago


Full example:
<script src="https://gist.github.com/1020308.js"> </script>


h3. Use cases

Topic exchanges have very broad set of use cases. Whenever a problem invovles multiple consumers/applications that selectively
pick what type of messages they want to receive, topic exchange should be evaluated. To name a few examples:

 * Distributing data relevant to specific geographic location, for example, points of sale
 * Background task processing done by multiple workers, each capable of handling specific set of tasks
 * Stocks price updates (and updates on other kinds of financial data)
 * News updates that involve categorization or tagging (for example, only for a particular sport or a  basketball team)
 * Orchestration of services of different kinds in the cloud
 * Distributed architecture/OS-specific software builds or packaging where each builder can handle only one architecture or OS




h2. Declaring/Instantiating exchanges

With Ruby AMQP gem, exchanges can be declared two ways: using {AMQP::Exchange#initialize} method that takes an optional callback or
with a number of convenience methods on {AMQP::Channel} instances:

 * {AMQP::Channel#direct}
 * {AMQP::Channel#default_exchange}
 * {AMQP::Channel#topic}
 * {AMQP::Channel#fanout}
 * {AMQP::Channel#headers}

Sections on specific exchange types (direct, fanout, headers, etc) provide plenty of examples of how these methods can be used.



h2. Publishing messages

To publish a message to an AMQP exchange, use {AMQP::Exchange#publish}:
<pre>
<code>
exchange.publish("Some payload")
</code>
</pre>


{AMQP::Exchange#publish} can accept any object that responds to `to_s`, not just string instances:
<script src="https://gist.github.com/1020336.js"> </script>

Payload is completely opaque to the library and is not modified in any way.


h3. Data serialization

You are encouraged to take care of data serialization before publishing (using JSON, Thrift, Protocol Buffers or other serialization library).
Note that because AMQP is a binary protocol, text formats like JSON largely lose their strong point of being easy to inspect as data travels across network,
so "BSON":http://bsonspec.org may be a good fit.

A few popular options for data serialization are

 * JSON: "json gem":https://rubygems.org/gems/json (part of standard Ruby library on Ruby 1.9) or "yajl-ruby":https://rubygems.org/gems/yajl-ruby (Ruby bindings to YAJL)
 * BSON: "bson gem":https://rubygems.org/gems/bson for JRuby (implemented as a Java extension) and "bson_ext":https://rubygems.org/bson_ext (C extension) for C-based Rubies.
 * "Message Pack":http://msgpack.org has Ruby bindings but currently does not provide Java implementation for JRuby
 * XML: "Nokogiri":https://nokogiri.org is a swiss army knife for XML processing with Ruby, built on top of libxml2.
 * Protocol Buffers: "beefcake":https://github.com/bmizerany/beefcake
 * Thrift: "thrift-client":https://github.com/fauna/thrift_client


h3. Message metadata

AMQP messages have various metadata attributes that can be set when a message is published. Some of the attributes are
well-known and mentioned in the AMQP 0.9.1 spec, others are specific to a particular application. Well-known attributes
(listed here as options {AMQP::Exchange#publish takes}) are:

 * :routing_key
 * :persistent
 * :immediate
 * :mandatory
 * :content_type
 * :content_encoding
 * :priority
 * :message_id
 * :correlation_id
 * :reply_to
 * :type
 * :user_id
 * :app_id
 * :timestamp
 * :expiration

All other attributes can be added to a *headers table* (in Ruby parlance, headers hash) that {AMQP::Exchange#publish} accepts as :headers.

An example to demonstrate how message metadata attributes as passed to {AMQP::Exchange#publish}:
<script src="https://gist.github.com/1020424.js"> </script>

<dl>
  <dt>:routing_key</dt>
  <dd>Used for routing messages depending on the exchange type and configuration</dd>

  <dt>:persistent</dt>
  <dd>When set (true), AMQP broker will persist message to disk. When off (false) </dd>

  <dt>:immediate</dt>
  <dd>
  This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set (true), the server will return
  to the producer an undeliverable message with a basic.return AMQP method. If this flag is off (false), the server will queue the message, but with no guarantee
  that it will ever be consumed.
  </dd>

  <dt>:mandatory</dt>
  <dd>
  This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set (true), the server will return an unroutable message
  to the producer with a basic.return AMQP method. If this flag is off (false), the server silently drops the message.
  </dd>

  <dt>:content_type</dt>
  <dd>MIME content type of message payload. Has the same purpose/semantics as HTTP Content-Type header</dd>

  <dt>:content_encoding</dt>
  <dd>MIME content encoding of message payload. Has the same purpose/semantics as HTTP Content-Encoding header</dd>

  <dt>:priority</dt>
  <dd>Message priority, from 0 to 9</dd>

  <dt>:message_id</dt>
  <dd>
    Message identifier as a string. If applications need to identify messages, it is recommended that they use this attribute instead of putting it
    into message payload
  </dd>

  <dt>:reply_to</dt>
  <dd>
    ID of the message this message is a reply to. Applications are encouraged to use this attribute instead of putting this information
    into message payload
  </dd>

  <dt>:correlation_id</dt>
  <dd>TBD: spec description raises more questions than provides answers, we need to check with broker implementers. MK.</dd>

  <dt>:type</dt>
  <dd>Message type as a string. Recommended to be used by applications instead of including this information into message payload.</dd>

  <dt>:user_id</dt>
  <dd>
  Sender's identifier. Note that RabbitMQ will check that "value of this attribute is the same as username AMQP connection was authenticated with":http://www.rabbitmq.com/extensions.html#validated-user-id, it SHOULD NOT be used to transfer, for example, other application user ids or be used as a basis for some kind of Single Sign-On solution..
  </dd>

  <dt>:app_id</dt>
  <dd>Application identifier string, for example, "eventoverse" or "webcrawler"</dd>

  <dt>:timestamp</dt>
  <dd>Timestamp of the moment when message was sent, in seconds since the Epoch</dd>

  <dt>:expiration</dt>
  <dd>Message expiration specification as a string</dd>

  <dt>:headers</dt>
  <dd>A Ruby hash of any additional attributes application needs. Nesting is supported.</dd>
</dl>

TBD


h3. Publishing callback. Reliable delivery in distributed environments

Sometimes it is convenient to execute an operation after publishing a message. For this, {AMQP::Exchange#publish} provides an optional
callback. It is important to clear up some expectations of when exactly it is run and how it is related to topics of message persistence,
delivery reliability and so on.

<pre>
<code>
exchange.publish(payload, :persistent => true, :type => "reports.done") do
  # ...
end
</code>
</pre>

A common expectation of the code above is that it is run after message "has been sent", or even "has been delivered". Unfortunately, neither of
this expectations can be met by the Ruby amqp gem alone. Message publishing happens in several steps:

 * {AMQP::Exchange#publish} takes a message and various metadata attributes
 * {AMQP::Exchange#publish} internally calls #to_s on the message argument to get message payload
 * Resulting payload is staged for writing
 * On the next event loop tick, data is transferred to the OS kernel using one of underlying system calls ("epoll":http://en.wikipedia.org/wiki/Epoll, "kqueue":http://en.wikipedia.org/wiki/Kqueue and so on)
   or NIO channels (in case of JRuby)
 * OS kernel buffers data before sending it
 * Network driver may also employ buffering

<span class="note">
As you can see, "when data is sent" is a complicated issue and while means to flush buffers certainly exist on various platforms, doing so in
a cross-platform way that *includes JVM* (that EventMachine also runs on) is rather non-trivial. In addition, even this does not guarantee that
data was received by the broker because it may crash while data was travelling down the wire. The only way to reliably know whether data was
received by the broker or peer application is to use message acknowledgements. This is how TCP works and this approach is proven to work at
enormous scale of the modern Internet. AMQP (the protocol) fully embraces this fact and amqp gem follows.
</span>

Given all this, when does {AMQP::Exchange#publish} callback fire? The answer is on the next event loop tick. By then data is pushed down to
the OS kernel. As far as Ruby library is concerned, it is a reasonably safe behavior.

<span class="note">
AMQP::Exchange#publish callback is fired on the next event loop tick. Data is staged for delivery immediately. Applications MUST NOT assume that
by the time the callback had fired, data is guaranteed to leave local machine networking stack or reach AMQP broker, leave alone peer(s)
message will be routed to.
</span>

In cases when not a single message may be lost, AMQP 0.9.1 applications can use one (or combination of) the following protocol features:

 * Publisher confirms (a RabbitMQ-specific extension to AMQP 0.9.1)
 * Publishing messages as immediate and/or mandatory
 * Transactions (have noticeable overhead and relatively narrow set of use cases)

More detailed overview of pros and cons of each option can be found in a "blog post that introduces Publisher Confirms extension":http://bit.ly/rabbitmq-publisher-confirms by the RabbitMQ team.
Next sections of this guide will describe how those features can be used with the Ruby amqp gem.


h3. Publishing messages as immediate. Returned messages.

When publishing messages, it is possible to use :immediate option to publish message as "immediate". When an immediate message cannot be
routed to any queue (it can be that there are no bindings for the exchange or none of the bindings matches), it is returned to the
producer. Producer then can handle that message, for example:

 * Store it for later redelivery in a persistent store like Redis or Riak
 * Publish it to a different destination
 * Log the event and discard the message

An example of {AMQP::Exchange#publish} being used to publish an immediate message:

<pre>
<code>
exchange.publish("Message ##{i}", :immediate => true)
</code>
</pre>


Returned messages have information about the exchange they were published to. For convenience, amqp gem associates returned messages callbacks with {AMQP::Exchange}
instances. To handle returned messages, use {AMQP::Exchange#on_return}:

<pre>
<code>
exchange.on_return do |basic_return, metadata, payload|
  puts "#{payload} was returned! reply_code = #{basic_return.reply_code}, reply_text = #{basic_return.reply_text}"
end
</code>
</pre>

Returned message handler has access to AMQP method (basic.return) information, message metadata and payload. Metadata and message body are returned exactly
as is, without modifications, so application can store it for later redelivery.


Full example:
<script src="https://gist.github.com/1025700.js"></script>


h3. Publishing messages as mandatory.

TBD


h3. Sending one-off messages

The following example publishes a message and *safely* closes AMQP connection after that by passing a block
to {AMQP::Exchange#publish}:

<script src="https://gist.github.com/1020425.js"> </script>



h2. Headers exchanges

Now that message attributes and publishing are introduced, time to take a look at one more core exchange type in AMQP 0.9.1. It is called
headers exchange type and is quite powerful.

h3. How headers exchanges route messages

h4. An example problem definition

The best way to explain headers-based routing is with an example. Imagine a distributed "continuous integration":http://martinfowler.com/articles/continuousIntegration.html system
that distributes builds across multiple machines with different hardware architectures (x86, IA-64, AMD64, ARM family and so on) and operating systems.
It strives to provide a way for community to contribute machines to run tests on and nice build matrix like "the one WebKit uses":http://build.webkit.org/waterfall?category=core.
One key problem such system faces is build distribution. Wouldn't it be nice if messaging broker could figure out
what machine has what OS, architecture or combination of the two and route build request messages there?

Headers exchange is designed to help in situations like this one: routing on multiple attributes that are easier expressed as
message metadata attributes (headers) than a routing key string.

h4. Routing on multiple message attributes

Headers exchanges route messages based on message header matching. Header exchanges ignore routing key attribute. Instead, attributes used for routing
are taken from the `headers` attribute. When a queue is bound to a headers exchange, :arguments attribute is used to define matching rules:

<pre>
<code>
# when binding to a headers exchange, :arguments parameter is used to specify matching rules
@channel.queue("", :auto_delete => true).bind(exchange, :arguments => { :os => 'linux' })
</code>
</pre>

When matching on one header, message is considered matching if value of the header equals value specified upon binding. Using the example above,
some messages that are matching:

<pre>
<code>
exchange.publish "For linux/IA64",   :headers => { :arch => "IA64", :os => 'linux' }
exchange.publish "For linux/x86",    :headers => { :arch => "x86",  :os => 'linux' }
exchange.publish "For any linux",    :headers => { :os => 'linux' }
</code>
</pre>

The following example demonstrates matching on integer values:

<pre>
<code>
# consumer part
@channel.queue("", :auto_delete => true).bind(exchange, :arguments => { :cores => 8 })

# ...

# producer part
exchange.publish "For ocotocore", :headers => { :cores => 8 }
</code>
</pre>

Matching on hashes (in AMQP 0.9.1 parlance, attribute tables) is also supported:

<pre>
<code>
# consumer part
channel.queue("", :auto_delete => true).bind(exchange, :arguments => { :package => { :name => 'riak', :version => '0.14.2' } })

# ...

# producer part
exchange.publish "For nodes with Riak 0.14.2", :headers => { :package => { :name => 'riak', :version => '0.14.2' } }
</code>
</pre>

h4. Matching all vs. matching one

It is possible to bind a queue to a headers exchange using more than one header for matching. In this case, broker needs one more piece of
information from application developer: should it consider messages with any of the headers matching, or all of them? This is what `x-match`
binding argument is for:

<pre>
<code>
channel.queue("", :auto_delete => true).bind(exchange, :arguments => { 'x-match' => 'all', :arch => "ia64", :os => 'linux' })
</code>
</pre>

In the example above, only messages that have `arch` header value equal to "ia64" and `os` header value equal to "linux" will
be considered matching.

<pre>
<code>
channel.queue("", :auto_delete => true).bind(exchange, :arguments => { 'x-match' => 'any', :os => 'macosx', :cores => 8 })
</code>
</pre>

When "x-match" argument is set to "any", just one matching header value is sufficient. So in the example above, any message with
`cores` header value equal to 8 will be considered matching.

TBD

h4. More examples

TBD


h3. Declaring a headers exchange

There are two ways to declare a headers exchange: using by instantiating {AMQP::Exchange} and specifying type as `:headers`, or
with {AMQP::Channel#headers}. Two examples to demonstrate:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :headers, "builds")
</code>
</pre>

<pre>
<code>
exchange = channel.headers("builds")
</code>
</pre>

Both methods asynchronously declare a queue. Because declaration takes a network roundtrip, publishing operations on {AMQP::Exchange} instances are
delayed until broker reply (exchange.declare-ok) is received.


Both methods let you pass a block to run a piece of code when broker responds with exchange.declare-ok (meaning exchange is successfully declared).

<pre>
<code>
channel.headers("builds") do |exchange|
  # exchange is declared and ready to be used.
end
</code>
</pre>


h3. Routing example

Full example:
<script src="https://gist.github.com/1034875.js"> </script>


h3. Use cases

TBD


h3. Pre-declared headers exchanges

AMQP 0.9.1 brokers should (as defined by "IETF RFC 2119":http://www.ietf.org/rfc/rfc2119.txt) implement headers exchange type
and pre-declare one instance with the name of "amq.match". RabbitMQ also pre-declares one instance with the name of "amq.headers".
Applications can rely on that exchange to always be available to them. Each vhost has a separate instance of that exchange,
it is *not shared across vhosts* for obvious reasons.




h2. Custom exchange types

h3. x-random

"x-random AMQP exchange type":https://github.com/jbrisbin/random-exchange is a custom exchange type developed as a
RabbitMQ plugin by Jon Brisbin. To quote project README:

bq. It is basically a direct exchange, with the exception that, instead of each consumer bound to that exchange with the
    same routing key getting a copy of the message, the exchange type randomly selects a queue to route to.

This plugin is licensed under "Mozilla Public License 1.1":http://www.mozilla.org/MPL/MPL-1.1.html, same as RabbitMQ.

h3. x-recent-history

"x-recent-history AMQP exchange type":https://github.com/videlalvaro/rabbitmq-recent-history-exchange is a customer exchange type
implemented as a RabbitMQ plugin by Alvaro Videla, one of the authors of "RabbitMQ in action":http://bit.ly/rabbitmq.

This plugin is licensed under the "MIT license":https://github.com/videlalvaro/rabbitmq-recent-history-exchange/blob/master/LICENSE.md.



h2. Using Publisher Confirms extension to AMQP 0.9.1

Please refer to {file:docs/VendorSpecificExtensions.textile Vendor-specific extensions to AMQP 0.9.1 spec}



h3. Message acknowledgements. Their relation to transactions and publisher confirms.

Consumer applications (applications that receive and process messages) may (and will) occasionally fail to process individual messages, or will just
crash. That's not to mention possible network issues. This raises a question: when should AMQP broker remove messages from queues? This
topic is covered in depth in the {file:docs/Queues.textile Working With Queues} guide, including prefetching and examples.

In this guide, we will only mention how message acknowledgements are related to AMQP transactions and Publisher Confirms extension.
Lets consider a publisher application P that communications with a consumer C using AMQP 0.9.1. Their communication can be graphically
represented like this:

<pre>
-----       -----       -----
|   |   S1  |   |   S2  |   |
| P | ====> | B | ====> | C |
|   |       |   |       |   |
-----       -----       -----
</pre>

We have two network segments, S1 and S2. Each of them may fail. Application P is concerned with making sure that messages cross S1,
while broker and application C are concerned with the fact that messages cross S2 and are only removed from the queue when
they are processed successfully.

Message acknowledgements cover reliable delivery over S2 and successful processing. For S1, P has to use transactions (a heavyweight solution) or
lightweight Publisher Confirms, a RabbitMQ-specific extension.


h2. Using AMQP transactions

TBD



h2. Binding queues to exchanges

Queues are bound to exchanges using {AMQP::Queue#bind} method. This topic is described in detail in the {file:docs/Queues.textile Working with queues}
documentation guide.



h2. Unbinding queues from exchanges

Queues are unbound from exchanges using {AMQP::Queue#unbind} method. This topic is described in detail in the {file:docs/Queues.textile Working with queues}
documentation guide.


h2. Deleting exchange

h3. Explicitly deleting an exchange

Exchanges are deleted using {AMQP::Exchange#delete} method:

<pre>
<code>
exchange.delete
</code>
</pre>

{AMQP::Exchange#delete} takes an optional callback that is run when `exchange.delete-ok` arrives from the broker.

<pre>
<code>
exchange.delete do |delete_ok|
  # by now exchange is guaranteed to be deleted
end
</code>
</pre>

h3. Auto-deleted exchanges

Exchanges are be *auto-deleted*. To declare an exchange as auto-deleted, use :auto_delete option on declaration:

<pre>
<code>
exchange = AMQP::Exchange.new(channel, :direct, "nodes.metadata", :auto_delete => true)
</code>
</pre>

<pre>
<code>
exchange = channel.direct("nodes.metadata", :auto_delete => true)
</code>
</pre>


Full example:
<script src="https://gist.github.com/1020226.js"> </script>

TBD: explain when exchange is considered to be "no longer in use"


h2. Objects as message producers.

Since Ruby is a genuine object-oriented language, it is important to demonstrate how Ruby amqp gem can be integrated
into rich object-oriented code. This guide focuses on exchanges and problems/solutions producer applications
(apps that primarily generate and publish messages, as opposed to consumers that receive and process them).

Full example:
<script src="https://gist.github.com/1009425.js"> </script>

TBD



h2. Exchange durability vs Message durability

See {file:docs/Durability.textile Durability guide}



h2. Error handling and recovery

See {file:docs/ErrorHandling.textile Error handling and recovery guide}



h2. Vendor-specific extensions related to exchanges

See {file:docs/VendorSpecificExtensions.textile Vendor-specific Extensions guide}



h2.  What to read next

Documentation is organized as several {file:docs/DocumentationGuidesIndex.textile documentation guides}, covering all kinds of
topics. Guides related to this one are

 * {file:docs/Durability.textile Durability and message persistence}
 * {file:docs/Bindings.textile Bindings}
 * {file:docs/Routing.textile Routing}
 * {file:docs/Queues.textile Working With Queues}
 * {file:docs/ErrorHandling.textile Error handling and recovery}




h2. Tell us what you think!

Please take a moment and tell us what you think about this guide on "Ruby AMQP mailing list":http://groups.google.com/group/ruby-amqp:
what was unclear? what wasn't covered? maybe you don't like guide style or grammar and spelling are incorrect? Readers feedback is
key to making documentation better.

If mailing list communication is not an option for you for some reason, you can "contact guides author directly":mailto:michael@novemberain.com?subject=amqp%20gem%20documentation


<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rubyamqpdocs'; // required: replace example with your forum shortname

    var disqus_developer = 0; // set to 1 on local machine for testing comments
    var disqus_identifier = 'amqp_exchanges';
    var disqus_url = 'http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Exchanges.textile';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
