<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en'>
  <head>
    <title>Testing AMQP applications</title>
    <meta content='width=device-width, initial-scale=1.0' name='viewport' />
    <meta content='A dead easy to use RabbitMQ Ruby client' name='description' />
    <meta content='The Ruby RabbitMQ Client Maintainers Team' name='author' />
    <link href='/assets/stylesheets/bootstrap.css' media='screen' rel='stylesheet' type='text/css' />
    <link href='/assets/stylesheets/bootstrap-responsive.css' media='screen' rel='stylesheet' type='text/css' />
    <link href='/assets/stylesheets/sass/styles.css' media='screen' rel='stylesheet' type='text/css' />
    <link href='/assets/stylesheets/pygments.css' media='screen' rel='stylesheet' type='text/css' />
    <link href='http://fonts.googleapis.com/css?family=Signika+Negative:300,400,600' rel='stylesheet' type='text/css' />
    <script src='/assets/javascripts/jquery-1.7.min.js' type='text/javascript'></script>
    <script src='/assets/javascripts/toc.js'></script>
    <script src='/assets/javascripts/bootstrap-collapse.js'></script>
    <meta content='text/html;charset=utf-8' http-equiv='Content-Type' />
    <script type="text/javascript">
      if(!(window.location.hostname === "localhost")) {
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-27153041-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
      }
    </script>
  </head>

  <body>
    <div class='navbar navbar-inverse navbar-fixed-top'>
      <div class='navbar-inner'>
        <div class='container-fluid'>
          <a class='btn btn-navbar' data-target='.nav-collapse' data-toggle='collapse'>
            <span class='icon-bar'></span>
            <span class='icon-bar'></span>
            <span class='icon-bar'></span>
          </a>
          <a class='brand' href='/'>Ruby amqp gem</a>
          <div class='nav-collapse'>
            <ul class='nav'>
            <li>
              <a href="/">Home</a>
            </li>
            <li>
              <a href="/articles/guides.html">All guides</a>
            </li>
            <li>
              <a href='/articles/community.html'>Community</a>
            </li>
            <li>
              <a href='http://rubybunny.info'>Bunny, an alternative client</a>
            </li>
            <li>
              <a href='https://github.com/ruby-amqp/amqp'>Code on Github</a>
            </li>
            <li>
              <a href='http://github.com/ruby-amqp'>Other RabbitMQ Ruby clients</a>
            </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class='container-fluid'>
      <div class='row-fluid'>
        <div class='span3'>
          <div class='well sidebar-nav'></div>
        </div>
        <div class='span9'>
          <h1>Testing AMQP applications</h1>
          <h2 id="about-this-guide">About this guide</h2>

<p>This guide covers unit testing of amqp-based applications, primarily
using <a href="http://github.com/ruby-amqp/evented-spec">evented-spec</a>.</p>

<h2 id="covered-versions">Covered versions</h2>

<p>This guide covers Ruby amqp gem 1.7.x and <a href="http://github.com/ruby-amqp/evented-spec">evented-spec gem</a>
0.9.0 and later.</p>

<h2 id="rationale">Rationale</h2>

<p>The AMQP 0.9.1 protocol is inherently asynchronous. Testing of asynchronous
code is often more difficult than synchronous code. There are two
approaches to it:</p>

<ul>
<li>Stubbing out a big chunk of the environment</li>
<li>Using a &quot;real&quot; environment</li>
</ul>

<p>The former is risky because your application becomes divorced from the
actual behavior of other applications. The latter approach is more
reliable but at the same time more tedious, because there is a certain
amount of incidental complexity that a &quot;real&quot; environment carries.</p>

<p>However, a lot of this complexity can be eliminated with tools and
libraries. The evented-spec gem is one of those tools. It grew out of
the necessity to test <a href="http://github.com/ruby-amqp/amqp">amqp Ruby gem</a>
and has proven to be both very powerful and easy to use. This guide
covers the usage of that gem in the context of applications that use the
amqp gem but can also be useful for testing EventMachine and
Cool.io-based applications.</p>

<h2 id="using-evented-spec">Using evented-spec</h2>

<h3 id="setting-up">Setting up</h3>

<p>To start using amqp all you need is to include
<code>EventedSpec::AMQPSpec</code> module into your context and add
<code>#done</code> calls to your examples:</p>

<p>{ gist 1027377 }</p>

<h3 id="testing-in-the-asynchronous-environment">Testing in the Asynchronous Environment</h3>

<p>Since we are using callback mechanisms in order to provide asynchrony,
we have to deal with the situation when we expect a response and that
response never comes. The usual solution includes setting a timeout
which makes the given tests fail if they aren’t finished in a timely
manner. When <a class='highlight'>#done</a> is called, your tests
confirm successful ending of specs. Try removing
<a class='highlight'>done</a> from the above example and see what
happens. (spoiler:
<a class='highlight'>EventedSpec::SpecHelper::SpecTimeoutExceededError:
Example timed out</a>)</p>

<h3 id="the-done-method">The #done method</h3>

<p>The <a class='highlight'>#done</a> method call is a hint for
evented-spec to consider the example finished. If this method is not
called, example will be forcefully terminated after a certain period of
time or &quot;time out&quot;. This means there are two approaches to testing of
asynchronous code:</p>

<ul>
<li>Have timeout value high enough for all operations to finish (for
example, expected number of messages is received).\

<ul>
<li>Call #done when some condition holds true (for example, message
with a specific property or payload is received).</li>
</ul></li>
</ul>

<p>The latter approach is recommended because it makes tests less dependent
on machine-specific throughput or timing. It is very common for
continuous integration environments to use virtual machines that are
significantly less powerful than the machines that developers use, so
timeouts have to be carefully adjusted to work in both settings.</p>

<h3 id="default-connection-options-and-timeout">Default Connection Options and Timeout</h3>

<p>It is sometimes desirable to use custom connection settings for your
test environment as well as the default timeout value used. evented-spec
lets you do this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'spec_helper'</span>
<span class="nb">require</span> <span class="s1">'evented-spec'</span>

<span class="n">describe</span> <span class="s2">"Hello, world! example"</span> <span class="k">do</span>
  <span class="kp">include</span> <span class="no">EventedSpec</span><span class="o">::</span><span class="no">AMQPSpec</span>

  <span class="n">default_options</span> <span class="ss">:vhost</span> <span class="o">=&gt;</span> <span class="s2">"amqp_testing_vhost"</span>
  <span class="n">default_timeout</span> <span class="mi">1</span>

  <span class="n">it</span> <span class="s2">"should pass"</span> <span class="k">do</span>
    <span class="n">done</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Available options are passed to {AMQP.connect} so it is possible to
specify host, port, vhost, username and password arguments that your
test suite needs.</p>

<h3 id="lifecycle-callbacks">Lifecycle Callbacks</h3>

<p>evented-spec provides various callbacks similar to rspec’s
<a class='highlight'>before(:each)</a> /
<a class='highlight'>after(:each)</a>. They are called
<a class='highlight'>amqp_before</a> and
<a class='highlight'>amqp_after</a> and happen right after connection
is established or before connection is closed. It is a good place to put
your channel initialization routines.</p>

<h3 id="full-example">Full Example</h3>

<p>Now that you’re filled in on the theory, it’s time to do something with
all this knowledge. Below is a slightly modified version of one of the
integration specs from the amqp suite. It sets up a default topic
exchange and publishes various messages about sports events:</p>

<p>{ gist 1027478 }</p>

<p>A couple of things to notice: <a class='highlight'>#done</a> is invoked
using an optional callback and optional delay, also instance variables
behavior in hooks is the same as in &quot;normal&quot; rspec hooks.</p>

<h3 id="using-delayed">Using #delayed</h3>

<p>The amqp gem uses <a href="http://eventmachine.rubyforge.org/">EventMachine</a>
under the hood. If you don’t know about EventMachine, you can read more
about it on the official site. What’s important for us is that you
<strong>cannot use <a class='highlight'>sleep</a> for delays</strong>. Why? Because
all of the spec code is processed directly in the
<a href="http://en.wikipedia.org/wiki/Reactor_pattern">reactor</a> thread, if you
<a class='highlight'>sleep</a> in that thread, the reactor cannot send
frames. What you need to use instead is the
<a class='highlight'>#delayed</a> method. It takes delay time in
seconds and a callback that it fires once the delay time has elapsed.
Basic usage is either as a <a class='highlight'>sleep</a> replacement or
to ensure a certain order of execution (although, the latter should not
bother you too much). You can also use it to cleanup your environment
after tests if needed.</p>

<p>In the following example, we declare two channels, then declare the same
queue twice with the same name but different options (which raises a
channel-level exception in AMQP):</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="no">AMQP</span> <span class="k">do</span>
  <span class="kp">include</span> <span class="no">EventedSpec</span><span class="o">::</span><span class="no">AMQPSpec</span>
  <span class="n">default_timeout</span> <span class="mi">5</span>


  <span class="n">context</span> <span class="s2">"when queue is redeclared with different attributes across two channels"</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>              <span class="p">{</span> <span class="s2">"amqp-gem.nondurable.queue"</span> <span class="p">}</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:options</span><span class="p">)</span>           <span class="p">{</span>
      <span class="p">{</span> <span class="ss">:durable</span> <span class="o">=&gt;</span> <span class="kp">false</span><span class="p">,</span> <span class="ss">:passive</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:different_options</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">{</span> <span class="ss">:durable</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:passive</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">it</span> <span class="s2">"should trigger channel-level #on_error callback"</span> <span class="k">do</span>
      <span class="vi">@channel</span> <span class="o">=</span> <span class="no">AMQP</span><span class="o">::</span><span class="no">Channel</span><span class="p">.</span><span class="nf">new</span>
      <span class="vi">@channel</span><span class="p">.</span><span class="nf">on_error</span> <span class="k">do</span> <span class="o">|</span><span class="n">ch</span><span class="p">,</span> <span class="n">close</span><span class="o">|</span>
        <span class="nb">puts</span> <span class="s2">"This should never happen"</span>
      <span class="k">end</span>
      <span class="vi">@q1</span> <span class="o">=</span> <span class="vi">@channel</span><span class="p">.</span><span class="nf">queue</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

      <span class="c1"># backwards compatibility, please consider against</span>
      <span class="c1"># using global error handlers in your programs!</span>
      <span class="no">AMQP</span><span class="o">::</span><span class="no">Channel</span><span class="p">.</span><span class="nf">on_error</span> <span class="k">do</span> <span class="o">|</span><span class="n">msg</span><span class="o">|</span>
        <span class="nb">puts</span> <span class="s2">"Global handler has fired: </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">"</span>
        <span class="vi">@global_callback_fired</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>

      <span class="c1"># Small delays to ensure the order of execution</span>
      <span class="n">delayed</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>
        <span class="vi">@other_channel</span> <span class="o">=</span> <span class="no">AMQP</span><span class="o">::</span><span class="no">Channel</span><span class="p">.</span><span class="nf">new</span>
        <span class="vi">@other_channel</span><span class="p">.</span><span class="nf">on_error</span> <span class="k">do</span> <span class="o">|</span><span class="n">ch</span><span class="p">,</span> <span class="n">close</span><span class="o">|</span>
          <span class="vi">@callback_fired</span> <span class="o">=</span> <span class="kp">true</span>
        <span class="k">end</span>
        <span class="nb">puts</span> <span class="s2">"other_channel.id = </span><span class="si">#{</span><span class="vi">@other_channel</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">"</span>
        <span class="vi">@q2</span> <span class="o">=</span> <span class="vi">@other_channel</span><span class="p">.</span><span class="nf">queue</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">different_options</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="n">delayed</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span> <span class="p">{</span>
        <span class="vi">@q1</span><span class="p">.</span><span class="nf">delete</span>
        <span class="vi">@q2</span><span class="p">.</span><span class="nf">delete</span>
      <span class="p">}</span>

      <span class="n">done</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span> <span class="p">{</span>
        <span class="vi">@callback_fired</span><span class="p">.</span><span class="nf">should</span> <span class="n">be_true</span>
        <span class="vi">@global_callback_fired</span><span class="p">.</span><span class="nf">should</span> <span class="n">be_true</span>
        <span class="vi">@other_channel</span><span class="p">.</span><span class="nf">closed?</span><span class="p">.</span><span class="nf">should</span> <span class="n">be_true</span>
      <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span> <span class="c1"># describe AMQP</span>
</code></pre></div>
<p>If you draw a timeline, various events happen at 0.0s, then at 0.1s,
then at 0.3s and eventually at 0.4s.</p>

<h3 id="design-for-testability">Design For Testability</h3>

<p>As the <strong>Integration With Objects</strong> section of the <a href="/articles/getting_started/">Getting Started with
Ruby amqp gem and RabbitMQ</a> demonstrates,
good object-oriented design often makes it possible to test AMQP
consumers in isolation without connecting to the broker or even starting
the EventMachine event loop. All of the &quot;Design for testability&quot;
practices apply to AMQP application testing.</p>

<h3 id="real-world-examples">Real world Examples</h3>

<p>Please refer to the <a href="https://github.com/ruby-amqp/amqp/tree/master/spec">amqp gem test
suite</a> to see
evented-spec in action.</p>

<h3 id="how-evented-spec-works">How evented-spec Works</h3>

<p>When you include the <a class='highlight'>EventedSpec::AMQPSpec</a>
module, <a class='highlight'>#it</a> calls are wrapped in
<a class='highlight'>EventMachine.start</a> and
<a class='highlight'>AMQP.connect</a> calls, so you can start writing
your examples as if you’re connected. Please note that you still need to
open your own channel(s).</p>

<h2 id="what-to-read-next">What to read next</h2>

<p>There is a lot more to evented-spec than described in this guide.
<a href="http://rdoc.info/github/ruby-amqp/evented-spec/master">evented-spec
documentation</a>
covers that gem in more detail. For more code examples, see <a href="https://github.com/ruby-amqp/amqp/tree/master/spec">amqp Ruby
gem test suite</a>.</p>

        </div>
      </div>
    <footer class='footer'>
      <div class='container'>
        <p>This website was developed by the
          &nbsp;<a href='http://github.com/ruby-amqp'>Ruby RabbitMQ Client Maintainers Team</a>.</p>
        <p>Follow us on Twitter:
          &nbsp;<a href='http://twitter.com/rubyamqp'>rubyamqp</a>,&nbsp;<a href='http://twitter.com/michaelklishin'>Michael Klishin</a>,&nbsp;<a href='http://twitter.com/celldee'>Chris Duncan</a></p>
      </div>
    </footer>
  </body>
</html>
